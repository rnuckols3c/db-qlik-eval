<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Databricks vs Qlik Evaluation</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; }
  </style>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useMemo } = React;

    function EvaluationFramework() {
      const [showWeightGuide, setShowWeightGuide] = useState(false);
      const [showSubmitModal, setShowSubmitModal] = useState(false);
      const [submitterName, setSubmitterName] = useState('');
      const [submitterEmail, setSubmitterEmail] = useState('');
      const [isSubmitting, setIsSubmitting] = useState(false);
      const [submitSuccess, setSubmitSuccess] = useState(false);
      const [submitError, setSubmitError] = useState('');

      // All category multipliers default to 1.0
      const [metaWeights, setMetaWeights] = useState({
        coreBIAnalytics: 1.0,
        coreBIViz: 1.0,
        dataPlatform: 1.0,
        governance: 1.0,
        aiml: 1.0,
        devEx: 1.0,
        operations: 1.0,
        cost: 1.0,
        product: 1.0
      });

      const weightDefinitions = {
        1: { label: "Minimal",  description: "Nice to have, little impact on decision" },
        2: { label: "Low",      description: "Useful but not critical to success" },
        3: { label: "Moderate", description: "Important, noticeable impact on outcomes" },
        4: { label: "High",     description: "Very important, significant decision factor" },
        5: { label: "Critical", description: "Essential feature, major decision driver" }
      };

      // Ordered per your priority
      const [categories, setCategories] = useState([
        {
          name: "Core BI: Analytics & Interactivity",
          key: "coreBIAnalytics",
          items: [
            { name: "Data Modeling Flexibility",      weight: 3, db: '', qlik: '', notes: "Associative/semantic vs SQL-centric models" },
            { name: "Custom Calculations",            weight: 3, db: '', qlik: '', notes: "Function breadth, expressions, calc fields" },
            { name: "Global Filtering & Interactivity",weight: 3, db: '', qlik: '', notes: "Cross-dashboard filtering & interactions" },
            { name: "Self-Service Analytics",         weight: 3, db: '', qlik: '', notes: "Non-technical users can explore & build" },
            { name: "Drill-through Navigation",       weight: 3, db: '', qlik: '', notes: "Cross-page linking and drill paths" },
            { name: "Accessibility",                  weight: 3, db: '', qlik: '', notes: "Keyboard, screen readers, WCAG support" }
          ]
        },
        {
          name: "Core BI: Visualization & Design",
          key: "coreBIViz",
          items: [
            { name: "Standard Visualizations",         weight: 3, db: '', qlik: '', notes: "Core chart types readily available" },
            { name: "Layout Control & Design",         weight: 3, db: '', qlik: '', notes: "Grid/canvas flexibility" },
            { name: "Multi-level Visual Containers",   weight: 3, db: '', qlik: '', notes: "Nested containers / sections" },
            { name: "Thematics/Styling",               weight: 3, db: '', qlik: '', notes: "Themes, palettes, typography controls" },
            { name: "Summary Tables/Scoreboards",      weight: 3, db: '', qlik: '', notes: "KPI boards and compact summaries" },
            { name: "Mobile Responsiveness",           weight: 3, db: '', qlik: '', notes: "Usability across mobile form factors" }
          ]
        },
        {
          name: "Data Platform & Architecture",
          key: "dataPlatform",
          items: [
            { name: "Batch/Daily Data Refresh",        weight: 3, db: '', qlik: '', notes: "Reliable scheduled refresh & orchestration" },
            { name: "Data Governance",                 weight: 3, db: '', qlik: '', notes: "Centralized policies & fine-grained access" },
            { name: "Concurrency/Scalability",         weight: 3, db: '', qlik: '', notes: "Performance with many concurrent users" },
            { name: "Query Performance at Scale",      weight: 3, db: '', qlik: '', notes: "Large dataset responsiveness" },
            { name: "Real-time Data Refresh",          weight: 3, db: '', qlik: '', notes: "Streaming / low-latency updates" },
            { name: "Data Lineage & Observability",    weight: 3, db: '', qlik: '', notes: "End-to-end lineage and monitoring" }
          ]
        },
        {
          name: "Governance & Security",
          key: "governance",
          items: [
            { name: "Row-Level Security & Access Control", weight: 3, db: '', qlik: '', notes: "Fine-grained authorization" },
            { name: "Auditability & Lineage",              weight: 3, db: '', qlik: '', notes: "Audit logs and traceability" },
            { name: "Data Residency & Encryption",         weight: 3, db: '', qlik: '', notes: "At rest/in transit, regional controls" },
            { name: "Cross-tenant Isolation",              weight: 3, db: '', qlik: '', notes: "Workspace/data isolation" },
            { name: "Export/Print/Email Governance",       weight: 3, db: '', qlik: '', notes: "Controls for distribution/sharing" }
          ]
        },
        {
          name: "AI/ML Capabilities & Future Readiness",
          key: "aiml",
          items: [
            { name: "ML Model Integration",            weight: 3, db: '', qlik: '', notes: "Notebooks/languages and model lifecycle hooks" },
            { name: "Feature Engineering Pipeline",    weight: 3, db: '', qlik: '', notes: "Data prep/transform workflows for ML features" },
            { name: "Advanced Analytics (Stat/Predictive)", weight: 3, db: '', qlik: '', notes: "Built-in ML/AutoML options" },
            { name: "Conversational AI / NLQ",         weight: 3, db: '', qlik: '', notes: "Natural-language querying of data" },
            { name: "Real-time ML Inference",          weight: 3, db: '', qlik: '', notes: "Streaming ingestion + model serving" }
          ]
        },
        {
          name: "Developer Experience & Velocity",
          key: "devEx",
          items: [
            { name: "CI/CD & Version Control",         weight: 3, db: '', qlik: '', notes: "Git integration & deployment flows" },
            { name: "Time to Production",              weight: 3, db: '', qlik: '', notes: "Speed to first production release" },
            { name: "Feature Velocity",                weight: 3, db: '', qlik: '', notes: "Iteration speed post-launch" },
            { name: "Documentation & Support",         weight: 3, db: '', qlik: '', notes: "Quality of docs/community/vendor support" },
            { name: "Code Reusability",                weight: 3, db: '', qlik: '', notes: "Modules, shared libs, reusable assets" }
          ]
        },
        {
          name: "Operations & Scalability",
          key: "operations",
          items: [
            { name: "iFrame Embedding Capabilities",   weight: 3, db: '', qlik: '', notes: "Embed securely in external apps" },
            { name: "User Authentication & SSO",       weight: 3, db: '', qlik: '', notes: "SSO protocols & centralized auth" },
            { name: "Export Capabilities",             weight: 3, db: '', qlik: '', notes: "Export data/visuals to files/tools" },
            { name: "Monitoring & Observability",      weight: 3, db: '', qlik: '', notes: "Health metrics & query profiling" },
            { name: "SLA/Latency Guarantees",          weight: 3, db: '', qlik: '', notes: "Service levels & performance targets" },
            { name: "Maintenance/Version Management",  weight: 3, db: '', qlik: '', notes: "Upgrades, patching, versioning" }
          ]
        },
        {
          name: "Cost & Resources",
          key: "cost",
          items: [
            { name: "Platform Skill Footprint",        weight: 3, db: '', qlik: '', notes: "Skills needed to build/operate" },
            { name: "Cost Predictability",             weight: 3, db: '', qlik: '', notes: "Pricing clarity under usage variance" },
            { name: "Raw Cost Savings",                weight: 3, db: '', qlik: '', notes: "Total cost at scale" },
            { name: "Custom UI Dev/Maintenance",       weight: 3, db: '', qlik: '', notes: "Cost of bespoke frontends" },
            { name: "License Model Fit & Simplicity",  weight: 3, db: '', qlik: '', notes: "Ease for finance & budgeting" }
          ]
        },
        {
          name: "Product & Market",
          key: "product",
          items: [
            { name: "Product Vision Alignment",        weight: 3, db: '', qlik: '', notes: "Roadmap fit to long-term needs" },
            { name: "Product Momentum",                weight: 3, db: '', qlik: '', notes: "Adoption & innovation velocity" },
            { name: "Hireability",                     weight: 3, db: '', qlik: '', notes: "Availability of skilled talent" },
            { name: "Ecosystem & Integrations",        weight: 3, db: '', qlik: '', notes: "Connectors & partner marketplace" },
            { name: "Roadmap Transparency & Release Cadence", weight: 3, db: '', qlik: '', notes: "Clarity of plans & shipping pace" }
          ]
        }
      ]);

      // ---- helpers & safe setters ----
      const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
      const clampInt = (v, lo, hi) => Math.round(clamp(v, lo, hi));

      const updateScore = (catIdx, itemIdx, field, raw) => {
        const newCategories = [...categories];
        const item = { ...newCategories[catIdx].items[itemIdx] };

        if (field === 'weight') {
          const v = Number(raw);
          item.weight = Number.isFinite(v) ? clampInt(v, 1, 5) : 1;
        } else if (field === 'db' || field === 'qlik') {
          const v = Number(raw);
          item[field] = Number.isFinite(v) ? clamp(v, 0, 10) : 0;
        } else {
          item[field] = raw;
        }

        newCategories[catIdx].items[itemIdx] = item;
        setCategories(newCategories);
      };

      const updateMetaWeight = (key, value) => {
        const v = Number(value);
        setMetaWeights(prev => ({ ...prev, [key]: Number.isFinite(v) ? Math.max(0, v) : 0 }));
      };
      // ---- end helpers ----

      const handleSubmit = async () => {
        if (!submitterName || !submitterEmail) {
          setSubmitError('Please enter your name and email');
          return;
        }

        setIsSubmitting(true);
        setSubmitError('');

        const submissionData = {
          submitter_name: submitterName,
          submitter_email: submitterEmail,
          submission_date: new Date().toISOString(),
          final_scores: {
            databricks: results.finalDB.toFixed(2),
            qlik: results.finalQlik.toFixed(2)
          },
          category_multipliers: metaWeights,
          category_results: results.categories.map(cat => ({
            category: cat.category,
            multiplier: cat.multiplier,
            databricks_avg: cat.avgDB.toFixed(2),
            qlik_avg: cat.avgQlik.toFixed(2),
            databricks_weighted: cat.weightedDB.toFixed(2),
            qlik_weighted: cat.weightedQlik.toFixed(2)
          })),
          detailed_scores: categories.map(cat => ({
            category: cat.name,
            items: cat.items.map(item => ({
              feature: item.name,
              weight: item.weight,
              databricks_score: item.db,
              qlik_score: item.qlik,
              notes: item.notes
            }))
          }))
        };

        try {
          const response = await fetch('https://formspree.io/f/xkgqyqeo', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify(submissionData)
          });

          const responseData = await response.json();

          if (response.ok) {
            setSubmitSuccess(true);
            setTimeout(() => {
              setShowSubmitModal(false);
              setSubmitSuccess(false);
              setSubmitterName('');
              setSubmitterEmail('');
            }, 2000);
          } else {
            setSubmitError(`Failed to submit: ${responseData.error || responseData.errors?.[0]?.message || 'Unknown error'}`);
          }
        } catch (error) {
          setSubmitError(`Error: ${error.message}`);
        } finally {
          setIsSubmitting(false);
        }
      };

      const results = useMemo(() => {
        let totalWeightedDB = 0;
        let totalWeightedQlik = 0;
        let totalEffectiveWeight = 0;

        const categoryResults = categories.map(category => {
          const categoryMultiplier = Math.max(0, Number(metaWeights[category.key]) || 0);
          const sumOfWeights = category.items.reduce(
            (sum, item) => sum + (Number(item.weight) || 0), 0
          ) || 1; // avoid divide-by-zero

          let categoryWeightedDB = 0;
          let categoryWeightedQlik = 0;

          category.items.forEach(item => {
            const w  = Number(item.weight) || 0;
            const db = Number(item.db) || 0;
            const ql = Number(item.qlik) || 0;
            const normalizedWeight = (w / sumOfWeights) * categoryMultiplier;
            categoryWeightedDB  += db * normalizedWeight;
            categoryWeightedQlik += ql * normalizedWeight;
          });

          totalWeightedDB += categoryWeightedDB;
          totalWeightedQlik += categoryWeightedQlik;
          totalEffectiveWeight += categoryMultiplier;

          return {
            category: category.name,
            multiplier: categoryMultiplier,
            sumOfWeights,
            weightedDB: categoryWeightedDB,
            weightedQlik: categoryWeightedQlik,
            avgDB: categoryMultiplier ? categoryWeightedDB / categoryMultiplier : 0,
            avgQlik: categoryMultiplier ? categoryWeightedQlik / categoryMultiplier : 0
          };
        });

        const safeDenom = totalEffectiveWeight || 1;

        return {
          categories: categoryResults,
          totalWeightedDB,
          totalWeightedQlik,
          totalEffectiveWeight,
          finalDB: totalWeightedDB / safeDenom,
          finalQlik: totalWeightedQlik / safeDenom
        };
      }, [categories, metaWeights]);

      return (
        <div className="w-full max-w-7xl mx-auto p-6">
          <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
            <div className="flex items-center justify-between mb-2">
              <h1 className="text-3xl font-bold text-gray-900">Databricks vs Qlik Evaluation</h1>
              <button
                onClick={() => setShowSubmitModal(true)}
                className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-semibold shadow-sm"
              >
                <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                </svg>
                Submit Response
              </button>
            </div>
            <p className="text-gray-600 mb-4">Quantitative assessment framework</p>

            {/* Multipliers editor */}
            <div className="bg-gray-50 p-4 rounded-lg border border-gray-200 mb-4">
              <h3 className="font-semibold text-gray-700 mb-2">Category Multipliers</h3>
              <p className="text-sm text-gray-600 mb-4">
                Set strategic priority for each category by adjusting multipliers. A multiplier of 2.0× doubles a category's weight in the final calculation, while 0.5× reduces it by half. Use higher values (1.5-2.0× or higher) for critical categories and lower values (0.5-0.8×) for less relevant areas. Default is 1.0× for balanced weighting.
              </p>
              <div className="flex gap-16">
                <div className="space-y-2">
                  {[
                    { key: 'coreBIAnalytics', label: 'Core BI: Analytics & Interactivity' },
                    { key: 'coreBIViz',      label: 'Core BI: Visualization & Design' },
                    { key: 'dataPlatform',   label: 'Data Platform & Architecture' },
                    { key: 'governance',     label: 'Governance & Security' },
                    { key: 'aiml',           label: 'AI/ML Capabilities & Future Readiness' },
                  ].map(({ key, label }) => (
                    <div key={key} className="flex items-center gap-2">
                      <label className="text-sm text-gray-700 font-medium w-64">{label}</label>
                      <input
                        type="number"
                        step="0.1"
                        value={metaWeights[key]}
                        onChange={(e) => updateMetaWeight(key, e.target.value)}
                        className="w-16 px-2 py-1.5 border border-gray-300 rounded text-sm text-center"
                      />
                      <span className="text-sm text-gray-500">×</span>
                    </div>
                  ))}
                </div>
                <div className="space-y-2">
                  {[
                    { key: 'devEx',      label: 'Developer Experience & Velocity' },
                    { key: 'operations', label: 'Operations & Scalability' },
                    { key: 'cost',       label: 'Cost & Resources' },
                    { key: 'product',    label: 'Product & Market' },
                  ].map(({ key, label }) => (
                    <div key={key} className="flex items-center gap-2">
                      <label className="text-sm text-gray-700 font-medium w-64">{label}</label>
                      <input
                        type="number"
                        step="0.1"
                        value={metaWeights[key]}
                        onChange={(e) => updateMetaWeight(key, e.target.value)}
                        className="w-16 px-2 py-1.5 border border-gray-300 rounded text-sm text-center"
                      />
                      <span className="text-sm text-gray-500">×</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            {/* Weight scale helper */}
            <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
              <div className="flex items-start gap-3">
                <button onClick={() => setShowWeightGuide(!showWeightGuide)} className="flex-shrink-0 mt-0.5">
                  <svg className="h-5 w-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </button>
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-2">
                    <h4 className="font-semibold text-gray-900">Item Weight Scale (1–5)</h4>
                    <button onClick={() => setShowWeightGuide(!showWeightGuide)} className="text-xs text-blue-600 hover:text-blue-800">
                      {showWeightGuide ? 'Hide' : 'Show'} Guide
                    </button
